--- a/core/settings.py
+++ b/core/settings.py
@@ -1,6 +1,7 @@
 import json
 import os
 import config
+from core.logger import log
 
 class SettingsManager:
     def __init__(self):
@@ -13,9 +14,126 @@
             "input_device_index": None, # Default device
             "use_intelligence": False, # Default to Raw Mode (User Preference)
             "transcription_language": "auto", # auto, en, fr
+
+            # Voice-activated mode (Discord-like) tuning
+            # Start gate = Silero speech probability + adaptive noise floor (RMS dBFS margin)
+            "voice_activation_start_confirm_ms": 220,
+            "voice_activation_hangover_ms": 160,
+            "voice_activation_cooldown_ms": 350,
+            "voice_activation_pre_roll_ms": 550,
+            "voice_activation_min_segment_ms": 450,
+            "voice_activation_min_speech_ms": 220,
+            "voice_activation_max_segment_s": 60.0,
+            "voice_activation_start_speech_prob": 0.62,
+            "voice_activation_stop_speech_prob": 0.45,
+            "voice_activation_start_db_margin": 8.0,
+            "voice_activation_stop_db_margin": 4.0,
+            "voice_activation_noise_update_speech_prob": 0.20,
+            "voice_activation_noise_ema_alpha": 0.04,
+
+            # Transcription stability (faster-whisper decode options)
+            "decode_beam_size": 8,
+            "decode_temperature": 0.0,
+            "decode_best_of": 1,
+            "decode_patience": 1.0,
+            "decode_length_penalty": 1.0,
+            "decode_repetition_penalty": 1.08,
+            "decode_no_repeat_ngram_size": 0,
+            "decode_condition_on_previous_text": True,
+            "decode_no_speech_threshold": 0.6,
+            "decode_log_prob_threshold": -1.0,
+            "decode_compression_ratio_threshold": 2.35,
+            "language_detection_threshold": 0.6,
+            "language_detection_segments": 3,
+
+            # Noisy-audio second pass (quality-first, may add ~0.2-1.0s)
+            "decode_enable_noisy_second_pass": True,
+            "decode_noisy_beam_size": 10,
+            "decode_noisy_best_of": 1,
+            "decode_noisy_condition_on_previous_text": False,
+
+            # Sticky language (prevents FR/EN flip-flop when language is set to "auto")
+            "sticky_language_enabled": True,
+            "sticky_language_min_prob": 0.90,
+            "sticky_language_ttl_s": 180.0,
+            "sticky_language_redetect_interval_s": 60.0,
+
+            # Auto language disambiguation (FR/EN): only triggers extra decode when detection is ambiguous.
+            "auto_languages": ["en", "fr"],
+            "auto_language_ambiguity_min_prob": 0.88,
+            "auto_language_ambiguity_min_margin": 0.12,
+            "auto_language_force_on_short_utterance": True,
+            "auto_language_short_utterance_s": 2.5,
+
+            # Confidence heuristics (reject likely hallucinations / noise-only captures)
+            "reject_no_speech_prob": 0.85,
+            "reject_avg_logprob": -0.95,
+            "reject_min_chars": 2,
+
+            # Confidence classification thresholds (used to decide retry/LLM/reject)
+            "conf_high_min_avg_logprob": -0.55,
+            "conf_high_max_avg_no_speech_prob": 0.55,
+            "conf_high_max_avg_compression_ratio": 2.05,
+            "conf_med_min_avg_logprob": -0.85,
+            "conf_med_max_avg_no_speech_prob": 0.78,
+            "conf_med_max_avg_compression_ratio": 2.35,
+
+            # Injection behavior
+            "inject_typing_max_chars": 32,
+            "inject_terminal_always_paste": True,
+            "inject_clipboard_settle_ms": 80,
+            "inject_clipboard_restore_delay_ms": 550,
+            "inject_clipboard_retry_count": 6,
+            "inject_clipboard_retry_backoff_ms": 20,
+            "terminal_processes": [
+                "windowsterminal.exe",
+                "wt.exe",
+                "conhost.exe",
+                "cmd.exe",
+                "powershell.exe",
+                "pwsh.exe",
+                "openconsole.exe",
+                "wezterm.exe",
+                "alacritty.exe",
+                "mintty.exe",
+                "tabby.exe",
+                "hyper.exe",
+                "putty.exe",
+            ],
+            "paste_hotkey_order": ["ctrl+shift+v", "shift+insert", "ctrl+v"],
+
+            # LLM refinement safety (Ollama)
+            "ollama_timeout_s": 6.0,
+            "llm_refine_max_chars": 420,
+            "llm_refine_skip_code_like": True,
+            "llm_refine_min_confidence": "high",  # high|medium|low
+            "llm_refine_min_audio_s": 2.5,
+            "llm_refine_min_words": 6,
+
+            # Voice activation debug (logs segment summaries)
+            "voice_activation_debug": False,
+
+            # UI timing
+            "success_hold_ms": 350,
+
+            # Overlay skin
+            "overlay_skin": "matrix_rain",  # matrix_rain|dot|sauron_eye|sauron_qml
+
+            # Sauron eye skin tuning
+            "sauron_fire_fps_ms": 40,
             "setup_completed": False
         }
         self.settings = self.load_settings()
+
+    def _warn_and_prune_unknown_keys(self, raw: dict) -> dict:
+        if not isinstance(raw, dict):
+            return {}
+
+        known = set(self.defaults.keys())
+        unknown = sorted([k for k in raw.keys() if k not in known])
+        if unknown:
+            log(f"Unknown settings keys ignored: {unknown}", "warning")
+        return {k: v for k, v in raw.items() if k in known}
 
     def load_settings(self):
         if not os.path.exists(self.settings_path):
@@ -24,6 +142,7 @@
         try:
             with open(self.settings_path, 'r') as f:
                 data = json.load(f)
+                data = self._warn_and_prune_unknown_keys(data)
                 # Merge with defaults to ensure all keys exist
                 merged = self.defaults.copy()
                 merged.update(data)
@@ -44,6 +163,9 @@
         return self.settings.get(key, self.defaults.get(key))
 
     def set(self, key, value):
+        if key not in self.defaults:
+            log(f"Attempt to set unknown setting ignored: {key}", "warning")
+            return
         self.settings[key] = value
         self.save_settings()
 
--- a/ui/overlay.py
+++ b/ui/overlay.py
@@ -1,15 +1,76 @@
 import sys
 import random
+import math
+import os
 from PyQt6.QtWidgets import QApplication, QWidget, QMenu
-from PyQt6.QtCore import Qt, QTimer, pyqtSignal, QPoint
-from PyQt6.QtGui import QPainter, QColor, QFont, QAction, QCursor
-
-class MatrixRainWidget(QWidget):
+from PyQt6.QtCore import Qt, QTimer, QPoint, QObject, pyqtSignal, pyqtProperty, pyqtSlot, QUrl
+from PyQt6.QtGui import QPainter, QColor, QFont, QAction, QCursor, QImage
+from core.settings import manager as settings
+from core.logger import log
+
+try:
+    from PyQt6.QtQuick import QQuickView
+except Exception:
+    QQuickView = None
+
+class OverlayBaseWidget(QWidget):
     def __init__(self):
         super().__init__()
+        self.state = "IDLE"
+        self.locked = True
+        self.drag_pos = None
+
         # Window Flags: Frameless, On Top, Tool
-        self.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.WindowStaysOnTopHint | Qt.WindowType.Tool)
+        self.setWindowFlags(
+            Qt.WindowType.FramelessWindowHint
+            | Qt.WindowType.WindowStaysOnTopHint
+            | Qt.WindowType.Tool
+        )
         self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
+
+    def set_state(self, state):
+        self.state = state
+        self.update()
+
+    # --- Mouse Interaction ---
+    def mousePressEvent(self, event):
+        if event.button() == Qt.MouseButton.LeftButton:
+            if not self.locked:
+                self.drag_pos = event.globalPosition().toPoint() - self.frameGeometry().topLeft()
+
+    def mouseMoveEvent(self, event):
+        if event.buttons() == Qt.MouseButton.LeftButton and not self.locked and self.drag_pos:
+            self.move(event.globalPosition().toPoint() - self.drag_pos)
+
+    def contextMenuEvent(self, event):
+        menu = QMenu(self)
+
+        settings_action = QAction("Settings", self)
+        settings_action.triggered.connect(self.open_settings)
+        menu.addAction(settings_action)
+
+        lock_action = QAction("Lock Position" if not self.locked else "Unlock Position", self)
+        lock_action.triggered.connect(self.toggle_lock)
+        menu.addAction(lock_action)
+
+        quit_action = QAction("Quit", self)
+        quit_action.triggered.connect(QApplication.instance().quit)
+        menu.addAction(quit_action)
+
+        menu.exec(event.globalPos())
+
+    def open_settings(self):
+        if hasattr(self, "on_settings_click"):
+            self.on_settings_click()
+
+    def toggle_lock(self):
+        self.locked = not self.locked
+        self.update()
+
+
+class MatrixRainWidget(OverlayBaseWidget):
+    def __init__(self):
+        super().__init__()
         
         # Geometry: Start Bottom Right
         screen = QApplication.primaryScreen().geometry()
@@ -24,10 +85,6 @@
         
         self.setGeometry(x, y, self.width_, self.height_)
         
-        self.state = "IDLE" 
-        self.locked = True
-        self.drag_pos = None
-
         # Matrix Rain Config
         self.font_size = 10 # Dense
         self.columns = int(self.width_ / self.font_size)
@@ -41,10 +98,6 @@
         self.timer.start(50) 
         
         self.show()
-
-    def set_state(self, state):
-        self.state = state
-        self.update()
 
     def animate(self):
         # Update drops
@@ -120,46 +173,417 @@
                 
                 painter.drawText(x, int(char_y), text)
 
-    # --- Mouse Interaction ---
-    def mousePressEvent(self, event):
-        if event.button() == Qt.MouseButton.LeftButton:
-            if not self.locked:
-                self.drag_pos = event.globalPosition().toPoint() - self.frameGeometry().topLeft()
+
+class DotWidget(OverlayBaseWidget):
+    def __init__(self):
+        super().__init__()
+
+        screen = QApplication.primaryScreen().geometry()
+        self.size_ = 22
+        x = screen.width() - 60
+        y = screen.height() - 80
+        self.setGeometry(x, y, self.size_, self.size_)
+        self.show()
+
+    def paintEvent(self, event):
+        painter = QPainter(self)
+        painter.setRenderHint(QPainter.RenderHint.Antialiasing, True)
+
+        if self.state == "IDLE":
+            color = QColor(0, 255, 70, 110)
+        elif self.state == "LISTENING":
+            color = QColor(255, 60, 60, 220)
+        elif self.state == "PROCESSING":
+            color = QColor(70, 170, 255, 220)
+        elif self.state == "SUCCESS":
+            color = QColor(255, 255, 255, 220)
+        else:
+            color = QColor(0, 255, 70, 110)
+
+        # Subtle glow
+        painter.setBrush(QColor(color.red(), color.green(), color.blue(), min(70, color.alpha())))
+        painter.setPen(Qt.PenStyle.NoPen)
+        painter.drawEllipse(1, 1, self.size_ - 2, self.size_ - 2)
+
+        painter.setBrush(color)
+        painter.drawEllipse(5, 5, self.size_ - 10, self.size_ - 10)
+
+        if not self.locked:
+            painter.setPen(QColor(255, 255, 0, 200))
+            painter.setBrush(Qt.BrushStyle.NoBrush)
+            painter.drawEllipse(0, 0, self.size_ - 1, self.size_ - 1)
+
+
+class SauronEyeWidget(OverlayBaseWidget):
+    def __init__(self):
+        super().__init__()
+
+        screen = QApplication.primaryScreen().geometry()
+        self.width_ = 220
+        self.height_ = 120
+        x = screen.width() - 300
+        y = screen.height() - 220
+        self.setGeometry(x, y, self.width_, self.height_)
+
+        self._phase = 0.0
+        self._spin = 0.0
+
+        # Procedural flame (Doom-fire style) buffer, rendered to a small QImage and scaled up.
+        self._fire_w = 120
+        self._fire_h = 64
+        self._fire = [0] * (self._fire_w * self._fire_h)  # intensity 0..255
+        self._fire_img = QImage(self._fire_w, self._fire_h, QImage.Format.Format_RGBA8888)
+        self._fire_palette = self._build_fire_palette()
+        self._fire_flicker = 0.0
+        self._fire_seed = 0.0
+
+        self.timer = QTimer(self)
+        self.timer.timeout.connect(self.animate)
+        try:
+            self.timer.start(int(settings.get("sauron_fire_fps_ms")))
+        except Exception:
+            self.timer.start(40)
+
+        self.show()
+
+    def animate(self):
+        self._phase += 0.06
+        self._spin += 1.6 if self.state == "PROCESSING" else 0.3
+        self._fire_flicker += 0.10 if self.state in {"LISTENING", "PROCESSING"} else 0.06
+        self._fire_seed += 0.02
+        self._update_fire()
+        self.update()
+
+    @staticmethod
+    def _lerp(a: float, b: float, t: float) -> float:
+        return a + (b - a) * t
+
+    def _build_fire_palette(self):
+        # Palette ramps from transparent black -> deep red -> orange -> yellow-white.
+        pal = []
+        for i in range(256):
+            t = i / 255.0
+            if t < 0.30:
+                r = int(self._lerp(0, 120, t / 0.30))
+                g = int(self._lerp(0, 10, t / 0.30))
+                b = 0
+            elif t < 0.70:
+                tt = (t - 0.30) / 0.40
+                r = int(self._lerp(120, 255, tt))
+                g = int(self._lerp(10, 120, tt))
+                b = int(self._lerp(0, 20, tt))
             else:
-                # pass click through? (Difficult in PyQt without extensive Win32 API)
-                pass
-        
-    def mouseMoveEvent(self, event):
-        if event.buttons() == Qt.MouseButton.LeftButton and not self.locked and self.drag_pos:
-            self.move(event.globalPosition().toPoint() - self.drag_pos)
-
-    def contextMenuEvent(self, event):
-        menu = QMenu(self)
-        
-        settings_action = QAction("Settings", self)
-        settings_action.triggered.connect(self.open_settings)
-        menu.addAction(settings_action)
-
-        lock_action = QAction("Lock Position" if not self.locked else "Unlock Position", self)
-        lock_action.triggered.connect(self.toggle_lock)
-        menu.addAction(lock_action)
-        
-        quit_action = QAction("Quit", self)
-        quit_action.triggered.connect(QApplication.instance().quit)
-        menu.addAction(quit_action)
-        
-        menu.exec(event.globalPos())
-
-    def open_settings(self):
-        # We need to signal the main thread or pass the engine
-        # Since this runs in the UI process, we can emit a signal or call a callback if passed.
-        # Ideally, main.py should pass a callback.
-        if hasattr(self, 'on_settings_click'):
-            self.on_settings_click()
-
-    def toggle_lock(self):
+                tt = (t - 0.70) / 0.30
+                r = 255
+                g = int(self._lerp(120, 240, tt))
+                b = int(self._lerp(20, 120, tt))
+
+            # Alpha: low values stay faint; high values glow.
+            a = int(255 * (t ** 0.85))
+            pal.append((r, g, b, a))
+        return pal
+
+    def _state_fire_params(self):
+        # Returns (base_intensity, decay_base, decay_rand, wind_strength, opacity)
+        if self.state == "IDLE":
+            return 135, 14, 24, 1, 0.35
+        if self.state == "LISTENING":
+            return 255, 10, 18, 2, 0.75
+        if self.state == "PROCESSING":
+            return 210, 12, 22, 3, 0.60
+        if self.state == "SUCCESS":
+            return 175, 12, 20, 1, 0.50
+        return 135, 14, 24, 1, 0.35
+
+    def _update_fire(self):
+        w, h = self._fire_w, self._fire_h
+        base_intensity, decay_base, decay_rand, wind_strength, _ = self._state_fire_params()
+
+        # Seed bottom line with flickery intensity.
+        pulse = 0.6 + 0.4 * math.sin(self._fire_flicker)
+        for x in range(w):
+            jitter = random.randint(-35, 35)
+            v = int(base_intensity * pulse) + jitter
+            self._fire[(h - 1) * w + x] = max(0, min(255, v))
+
+        # Propagate upward.
+        # Classic doom-fire: each cell takes from below and decays, with small horizontal drift (wind).
+        # Iterate from bottom-2 up to 0.
+        wind = int(wind_strength * math.sin(self._fire_seed * 6.0))
+        for y in range(h - 2, -1, -1):
+            row = y * w
+            below = (y + 1) * w
+            for x in range(w):
+                src = below + x
+                decay = decay_base + random.randint(0, decay_rand)
+                v = self._fire[src]
+                nv = v - int(decay * 0.6)
+                if nv < 0:
+                    nv = 0
+
+                # Drift slightly left/right with randomness + wind.
+                drift = random.randint(-1, 1) + wind
+                dx = x + drift
+                if dx < 0:
+                    dx = 0
+                elif dx >= w:
+                    dx = w - 1
+                self._fire[row + dx] = nv
+
+        # Render to QImage
+        ptr = self._fire_img.bits()
+        ptr.setsize(w * h * 4)
+        buf = memoryview(ptr)
+        pal = self._fire_palette
+
+        # Slight vertical fade (top is more transparent)
+        for y in range(h):
+            fade = y / max(1, h - 1)
+            fade_a = int(255 * (fade ** 1.6))
+            for x in range(w):
+                v = self._fire[y * w + x]
+                r, g, b, a = pal[v]
+                a = (a * fade_a) // 255
+                i = (y * w + x) * 4
+                buf[i + 0] = r
+                buf[i + 1] = g
+                buf[i + 2] = b
+                buf[i + 3] = a
+
+    def paintEvent(self, event):
+        painter = QPainter(self)
+        painter.setRenderHint(QPainter.RenderHint.Antialiasing, True)
+
+        # State-driven intensity
+        if self.state == "IDLE":
+            glow = 60
+            iris = QColor(255, 120, 0, 170)
+            pupil = QColor(0, 0, 0, 220)
+        elif self.state == "LISTENING":
+            glow = 170
+            iris = QColor(255, 40, 0, 230)
+            pupil = QColor(0, 0, 0, 235)
+        elif self.state == "PROCESSING":
+            glow = 140
+            iris = QColor(255, 160, 40, 220)
+            pupil = QColor(0, 0, 0, 235)
+        elif self.state == "SUCCESS":
+            glow = 120
+            iris = QColor(255, 220, 120, 210)
+            pupil = QColor(0, 0, 0, 235)
+        else:
+            glow = 60
+            iris = QColor(255, 120, 0, 170)
+            pupil = QColor(0, 0, 0, 220)
+
+        # Background
+        bg_alpha = 18 if self.state == "IDLE" else 90
+        if not self.locked:
+            bg_alpha = 70
+        painter.fillRect(self.rect(), QColor(0, 0, 0, bg_alpha))
+
+        cx = self.width_ // 2
+        cy = self.height_ // 2
+
+        # Flames (behind the eye)
+        _, _, _, _, flame_opacity = self._state_fire_params()
+        painter.save()
+        painter.setOpacity(flame_opacity)
+        painter.setCompositionMode(QPainter.CompositionMode.CompositionMode_Screen)
+        # Draw flames slightly above the eye center, then a faint reflection below.
+        flame_w = int(self.width_ * 1.05)
+        flame_h = int(self.height_ * 1.10)
+        painter.drawImage(int(cx - flame_w // 2), int(cy - flame_h // 2 - 18), self._fire_img.scaled(flame_w, flame_h, Qt.AspectRatioMode.IgnoreAspectRatio, Qt.TransformationMode.SmoothTransformation))
+        painter.setOpacity(flame_opacity * 0.25)
+        painter.drawImage(int(cx - flame_w // 2), int(cy - flame_h // 2 + 28), self._fire_img.mirrored(False, True).scaled(flame_w, int(flame_h * 0.55), Qt.AspectRatioMode.IgnoreAspectRatio, Qt.TransformationMode.SmoothTransformation))
+        painter.restore()
+
+        # Outer glow (eye aura)
+        pulse = 0.5 + 0.5 * math.sin(self._phase)
+        aura = QColor(255, 60, 0, int(glow * (0.55 + 0.45 * pulse)))
+        painter.setPen(Qt.PenStyle.NoPen)
+        painter.setBrush(aura)
+        painter.drawEllipse(int(cx - 92), int(cy - 42), 184, 84)
+
+        # Sclera (dark eye white)
+        painter.setBrush(QColor(10, 10, 10, 200))
+        painter.drawEllipse(int(cx - 84), int(cy - 36), 168, 72)
+
+        # Iris
+        painter.setBrush(iris)
+        painter.drawEllipse(int(cx - 46), int(cy - 28), 92, 56)
+
+        # Pupil (vertical slit)
+        slit_w = 10 + int(4 * math.sin(self._phase * 1.7))
+        painter.setBrush(pupil)
+        painter.drawRoundedRect(int(cx - slit_w // 2), int(cy - 24), slit_w, 48, 6, 6)
+
+        # Fiery ring details
+        ring_alpha = int(120 + 80 * pulse)
+        painter.setBrush(Qt.BrushStyle.NoBrush)
+        painter.setPen(QColor(255, 200, 60, ring_alpha))
+        painter.drawEllipse(int(cx - 52), int(cy - 32), 104, 64)
+
+        # Processing spinner arc
+        if self.state == "PROCESSING":
+            painter.setPen(QColor(255, 255, 255, 160))
+            r_w, r_h = 120, 76
+            painter.drawArc(int(cx - r_w // 2), int(cy - r_h // 2), r_w, r_h, int(self._spin * 16), int(110 * 16))
+
+        # Unlock outline
+        if not self.locked:
+            painter.setPen(QColor(255, 255, 0, 200))
+            painter.setBrush(Qt.BrushStyle.NoBrush)
+            painter.drawRoundedRect(0, 0, self.width_ - 1, self.height_ - 1, 10, 10)
+
+
+def create_overlay_widget(skin: str) -> OverlayBaseWidget:
+    s = (skin or "").strip().lower()
+    if s == "dot":
+        return DotWidget()
+    if s == "sauron_eye":
+        return SauronEyeWidget()
+    if s == "sauron_qml":
+        try:
+            return QmlSauronEyeWindow()
+        except Exception as e:
+            log(f"Failed to load sauron_qml skin; falling back to sauron_eye: {e}", "warning")
+            return SauronEyeWidget()
+    return MatrixRainWidget()
+
+
+class OverlayController(QObject):
+    stateChanged = pyqtSignal()
+    lockedChanged = pyqtSignal()
+
+    def __init__(self, window, on_settings_click=None):
+        super().__init__()
+        self._window = window
+        self._state = "IDLE"
+        self._locked = True
+        self._on_settings_click = on_settings_click
+
+    @pyqtProperty(str, notify=stateChanged)
+    def state(self):
+        return self._state
+
+    @state.setter
+    def state(self, value):
+        v = str(value or "IDLE")
+        if v != self._state:
+            self._state = v
+            self.stateChanged.emit()
+
+    @pyqtProperty(bool, notify=lockedChanged)
+    def locked(self):
+        return bool(self._locked)
+
+    @locked.setter
+    def locked(self, value):
+        v = bool(value)
+        if v != self._locked:
+            self._locked = v
+            self.lockedChanged.emit()
+
+    @pyqtSlot(float, float)
+    def moveBy(self, dx, dy):
+        try:
+            pos = self._window.position()
+            self._window.setPosition(int(pos.x() + dx), int(pos.y() + dy))
+        except Exception:
+            pass
+
+    @pyqtSlot()
+    def openSettings(self):
+        try:
+            if self._on_settings_click:
+                self._on_settings_click()
+        except Exception:
+            pass
+
+    @pyqtSlot()
+    def toggleLock(self):
         self.locked = not self.locked
-        self.update()
+
+    @pyqtSlot()
+    def quit(self):
+        try:
+            QApplication.instance().quit()
+        except Exception:
+            pass
+
+
+class QmlSauronEyeWindow:
+    """
+    Thin wrapper so run_overlay() can treat QQuickView like our QWidget skins.
+    """
+
+    def __init__(self):
+        if QQuickView is None:
+            raise RuntimeError("PyQt6.QtQuick not available")
+
+        self._view = QQuickView()
+        self._view.setFlags(
+            Qt.WindowType.FramelessWindowHint
+            | Qt.WindowType.WindowStaysOnTopHint
+            | Qt.WindowType.Tool
+        )
+        self._view.setColor(QColor(0, 0, 0, 0))
+        self._view.setResizeMode(QQuickView.ResizeMode.SizeRootObjectToView)
+
+        qml_path = os.path.join(os.path.dirname(__file__), "qml", "SauronEye.qml")
+        if not os.path.exists(qml_path):
+            raise FileNotFoundError(qml_path)
+
+        # Controller is injected later by run_overlay so we can attach callbacks.
+        self._ctrl = None
+        self._qml_url = QUrl.fromLocalFile(os.path.abspath(qml_path))
+
+        # Initial geometry similar to other skins.
+        screen = QApplication.primaryScreen().geometry()
+        self._view.setWidth(260)
+        self._view.setHeight(150)
+        self._view.setPosition(screen.width() - 320, screen.height() - 260)
+
+    def ensure_loaded(self, on_settings_click=None):
+        if self._ctrl is not None:
+            return
+
+        self._ctrl = OverlayController(self._view, on_settings_click=on_settings_click)
+        self._view.rootContext().setContextProperty("ctrl", self._ctrl)
+        self._view.setSource(self._qml_url)
+
+        if self._view.status() == QQuickView.Status.Error:
+            errs = getattr(self._view, "errors", lambda: [])()
+            raise RuntimeError(str(errs))
+
+        self._view.show()
+
+    # Interface used by run_overlay
+    def set_state(self, state):
+        if self._ctrl is not None:
+            self._ctrl.state = state
+
+    def pos(self):
+        return self._view.position()
+
+    def move(self, pos):
+        try:
+            self._view.setPosition(pos)
+        except Exception:
+            self._view.setPosition(int(pos.x()), int(pos.y()))
+
+    def close(self):
+        self._view.close()
+
+    @property
+    def locked(self):
+        return True if self._ctrl is None else self._ctrl.locked
+
+    @locked.setter
+    def locked(self, v):
+        if self._ctrl is not None:
+            self._ctrl.locked = bool(v)
 
 def run_overlay(state_queue, on_settings_click=None, app=None):
     if app is None:
@@ -169,14 +593,45 @@
     # (MatrixWindow produces 'Qt.Tool' flag which is ignored by default quit logic)
     app.setQuitOnLastWindowClosed(False)
         
-    widget = MatrixRainWidget()
-    widget.on_settings_click = on_settings_click
+    widget = create_overlay_widget(settings.get("overlay_skin"))
+    if hasattr(widget, "ensure_loaded"):
+        widget.ensure_loaded(on_settings_click=on_settings_click)
+    else:
+        widget.on_settings_click = on_settings_click
+    last_skin = str(settings.get("overlay_skin") or "")
     
     # Check queue for updates
     timer = QTimer()
     def check_queue():
-        if not state_queue.empty():
+        nonlocal widget, last_skin
+
+        # Hot-swap skins if changed.
+        current_skin = str(settings.get("overlay_skin") or "")
+        if current_skin != last_skin:
+            pos = widget.pos()
+            locked = getattr(widget, "locked", True)
+            state = getattr(widget, "state", "IDLE")
+
+            try:
+                widget.close()
+            except Exception:
+                pass
+
+            widget = create_overlay_widget(current_skin)
+            if hasattr(widget, "ensure_loaded"):
+                widget.ensure_loaded(on_settings_click=on_settings_click)
+            else:
+                widget.on_settings_click = on_settings_click
+            widget.move(pos)
+            widget.locked = locked
+            widget.set_state(state)
+            last_skin = current_skin
+
+        # Drain to the latest state to avoid UI lag when updates come quickly.
+        state = None
+        while not state_queue.empty():
             state = state_queue.get()
+        if state is not None:
             widget.set_state(state)
     
     timer.timeout.connect(check_queue)
--- a/ui/settings_dialog.py
+++ b/ui/settings_dialog.py
@@ -70,8 +70,6 @@
                     self.device_combo.setCurrentIndex(self.device_combo.count() - 1)
         layout.addWidget(self.device_combo)
 
-        layout.addWidget(self.device_combo)
-
         # --- Language Lock ---
         layout.addWidget(QLabel("FORCE OUTPUT LANGUAGE"))
         self.lang_combo = QComboBox()
@@ -90,12 +88,33 @@
         
         layout.addWidget(self.lang_combo)
 
+        # --- Overlay Skin ---
+        layout.addWidget(QLabel("OVERLAY SKIN"))
+        self.skin_combo = QComboBox()
+        self.skin_combo.addItem("Matrix Rain", "matrix_rain")
+        self.skin_combo.addItem("Dot", "dot")
+        self.skin_combo.addItem("Eye of Sauron", "sauron_eye")
+        self.skin_combo.addItem("Eye of Sauron (QML)", "sauron_qml")
+        cur_skin = manager.get("overlay_skin")
+        idx = self.skin_combo.findData(cur_skin)
+        if idx >= 0:
+            self.skin_combo.setCurrentIndex(idx)
+        layout.addWidget(self.skin_combo)
+
         # --- Visualizer ---
+        layout.addWidget(QLabel("MIC LEVEL"))
         self.meter = QProgressBar()
         self.meter.setRange(0, 100)
         self.meter.setTextVisible(False)
         self.meter.setFixedHeight(10)
         layout.addWidget(self.meter)
+
+        layout.addWidget(QLabel("SPEECH PROBABILITY (VAD)"))
+        self.vad_meter = QProgressBar()
+        self.vad_meter.setRange(0, 100)
+        self.vad_meter.setTextVisible(False)
+        self.vad_meter.setFixedHeight(10)
+        layout.addWidget(self.vad_meter)
         
         # Start Metering (Efficient)
         self.audio_engine.start_metering()
@@ -157,8 +176,15 @@
 
     def update_meter(self):
         level = self.audio_engine.get_current_volume()
-        val = min(100, int(level * 100))
+        val = min(100, int(level))
         self.meter.setValue(val)
+
+        vad_prob = 0.0
+        try:
+            vad_prob = float(self.audio_engine.get_current_speech_prob())
+        except Exception:
+            vad_prob = 0.0
+        self.vad_meter.setValue(max(0, min(100, int(vad_prob * 100))))
 
     def closeEvent(self, event):
         # Stop metering when closed (X or Done)
@@ -174,6 +200,7 @@
                 manager.set("input_device_index", idx)
             
             manager.set("transcription_language", self.lang_combo.currentData())
+            manager.set("overlay_skin", self.skin_combo.currentData())
 
             if self.rb_ptt.isChecked():
                 manager.set("mode", "push_to_talk")
--- a/ui/qml/SauronEye.qml
+++ b/ui/qml/SauronEye.qml
@@ -0,0 +1,310 @@
+import QtQuick 2.15
+import QtQuick.Shapes 1.15
+
+Item {
+    id: root
+    width: 260
+    height: 150
+
+    // Provided by Python context property.
+    // ctrl.state: "IDLE"|"LISTENING"|"PROCESSING"|"SUCCESS"
+    // ctrl.locked: bool
+    // ctrl.moveBy(dx, dy)
+    // ctrl.openSettings(), ctrl.toggleLock(), ctrl.quit()
+
+    readonly property string state: (typeof ctrl !== "undefined" ? ctrl.state : "IDLE")
+    readonly property bool locked: (typeof ctrl !== "undefined" ? ctrl.locked : true)
+
+    function stateIntensity() {
+        if (state === "LISTENING") return 1.0
+        if (state === "PROCESSING") return 0.75
+        if (state === "SUCCESS") return 0.55
+        return 0.30
+    }
+
+    function bgAlpha() {
+        if (!locked) return 0.30
+        if (state === "IDLE") return 0.12
+        return 0.22
+    }
+
+    Rectangle {
+        anchors.fill: parent
+        radius: 14
+        color: Qt.rgba(0, 0, 0, bgAlpha())
+    }
+
+    // Flames: lightweight GPU-driven "particle" rectangles with random drift.
+    // This is not a true fluid sim, but looks good and stays cheap.
+    Item {
+        id: flames
+        anchors.fill: parent
+        clip: true
+        opacity: 0.25 + 0.55 * stateIntensity()
+
+        Repeater {
+            model: 70
+            Rectangle {
+                id: flame
+                width: 5 + Math.floor(Math.random() * 7)
+                height: 18 + Math.floor(Math.random() * 32)
+                radius: width
+                antialiasing: true
+                x: Math.random() * (flames.width - width)
+                y: flames.height + Math.random() * 60
+                opacity: 0.0
+                scale: 0.7 + Math.random() * 0.9
+
+                gradient: Gradient {
+                    GradientStop { position: 0.0; color: Qt.rgba(1.0, 1.0, 0.8, 0.00) }
+                    GradientStop { position: 0.25; color: Qt.rgba(1.0, 0.8, 0.2, 0.18) }
+                    GradientStop { position: 0.65; color: Qt.rgba(1.0, 0.35, 0.05, 0.32) }
+                    GradientStop { position: 1.0; color: Qt.rgba(0.35, 0.00, 0.00, 0.55) }
+                }
+
+                readonly property real baseDur: 900 + Math.random() * 1100
+                readonly property real baseDelay: Math.random() * 500
+                readonly property real drift: (Math.random() * 2.0 - 1.0)
+
+                SequentialAnimation on y {
+                    loops: Animation.Infinite
+                    PauseAnimation { duration: flame.baseDelay }
+                    NumberAnimation {
+                        from: flames.height + 40 + Math.random() * 50
+                        to: -60 - Math.random() * 80
+                        duration: flame.baseDur * (1.05 - 0.45 * root.stateIntensity())
+                        easing.type: Easing.OutCubic
+                    }
+                }
+
+                SequentialAnimation on opacity {
+                    loops: Animation.Infinite
+                    PauseAnimation { duration: flame.baseDelay }
+                    NumberAnimation { from: 0.0; to: 1.0; duration: 220; easing.type: Easing.OutQuad }
+                    NumberAnimation { from: 1.0; to: 0.0; duration: flame.baseDur * 0.85; easing.type: Easing.InQuad }
+                }
+
+                SequentialAnimation on x {
+                    loops: Animation.Infinite
+                    PauseAnimation { duration: flame.baseDelay }
+                    NumberAnimation {
+                        from: flame.x
+                        to: Math.max(0, Math.min(flames.width - flame.width, flame.x + 40 * flame.drift))
+                        duration: flame.baseDur * 0.75
+                        easing.type: Easing.InOutSine
+                    }
+                    NumberAnimation {
+                        from: Math.max(0, Math.min(flames.width - flame.width, flame.x + 40 * flame.drift))
+                        to: flame.x
+                        duration: flame.baseDur * 0.75
+                        easing.type: Easing.InOutSine
+                    }
+                }
+            }
+        }
+    }
+
+    // Eye glow + outline (almond/mandorla shape)
+    Item {
+        id: eye
+        anchors.centerIn: parent
+        width: 220
+        height: 90
+
+        readonly property color baseIris: (state === "LISTENING" ? "#ff2a00"
+                                        : state === "PROCESSING" ? "#ff9a28"
+                                        : state === "SUCCESS" ? "#ffd88a"
+                                        : "#ff7a18")
+
+        // Outer glow
+        Shape {
+            anchors.fill: parent
+            opacity: 0.25 + 0.55 * root.stateIntensity()
+            ShapePath {
+                strokeWidth: 10
+                strokeColor: Qt.rgba(1.0, 0.20, 0.0, 0.65)
+                fillColor: "transparent"
+                capStyle: ShapePath.RoundCap
+                joinStyle: ShapePath.RoundJoin
+
+                startX: 6; startY: height / 2
+                PathQuad { x: width - 6; y: height / 2; controlX: width / 2; controlY: -6 }
+                PathQuad { x: 6; y: height / 2; controlX: width / 2; controlY: height + 6 }
+            }
+        }
+
+        // Main sclera
+        Shape {
+            anchors.fill: parent
+            ShapePath {
+                strokeWidth: 2
+                strokeColor: Qt.rgba(1.0, 0.72, 0.25, 0.35)
+                fillColor: Qt.rgba(0.06, 0.06, 0.06, 0.85)
+                capStyle: ShapePath.RoundCap
+                joinStyle: ShapePath.RoundJoin
+
+                startX: 6; startY: height / 2
+                PathQuad { x: width - 6; y: height / 2; controlX: width / 2; controlY: 2 }
+                PathQuad { x: 6; y: height / 2; controlX: width / 2; controlY: height - 2 }
+            }
+        }
+
+        // Iris (gradient oval inside eye)
+        Rectangle {
+            anchors.centerIn: parent
+            width: 110
+            height: 62
+            radius: 34
+            color: "transparent"
+            border.width: 1
+            border.color: Qt.rgba(1.0, 0.85, 0.45, 0.35)
+
+            gradient: Gradient {
+                GradientStop { position: 0.0; color: Qt.rgba(1.0, 0.95, 0.60, 0.60) }
+                GradientStop { position: 0.35; color: Qt.rgba(1.0, 0.70, 0.18, 0.85) }
+                GradientStop { position: 1.0; color: Qt.rgba(0.35, 0.02, 0.00, 0.90) }
+            }
+        }
+
+        // Pupil (vertical slit)
+        Rectangle {
+            anchors.centerIn: parent
+            width: (state === "LISTENING" ? 9 : state === "PROCESSING" ? 11 : 13)
+            height: 62
+            radius: 6
+            color: Qt.rgba(0, 0, 0, 0.92)
+        }
+
+        // A couple of fiery streaks (subtle)
+        Repeater {
+            model: 8
+            Rectangle {
+                width: 4 + Math.floor(Math.random() * 6)
+                height: 26 + Math.floor(Math.random() * 18)
+                radius: width
+                color: Qt.rgba(1.0, 0.5, 0.08, 0.10 + 0.20 * root.stateIntensity())
+                x: 50 + Math.random() * (eye.width - 100)
+                y: 10 + Math.random() * (eye.height - 20)
+                rotation: -18 + Math.random() * 36
+                opacity: 0.25 + 0.25 * root.stateIntensity()
+
+                SequentialAnimation on opacity {
+                    loops: Animation.Infinite
+                    NumberAnimation { from: 0.08; to: 0.35; duration: 520 + Math.random() * 400; easing.type: Easing.InOutSine }
+                    NumberAnimation { from: 0.35; to: 0.08; duration: 520 + Math.random() * 400; easing.type: Easing.InOutSine }
+                }
+            }
+        }
+    }
+
+    // Custom context menu (no QtQuick.Controls dependency)
+    Item {
+        id: menu
+        visible: false
+        anchors.right: parent.right
+        anchors.bottom: parent.bottom
+        anchors.margins: 10
+        width: 170
+        height: 116
+
+        Rectangle {
+            anchors.fill: parent
+            radius: 10
+            color: Qt.rgba(0.06, 0.06, 0.06, 0.92)
+            border.width: 1
+            border.color: Qt.rgba(1.0, 1.0, 1.0, 0.15)
+        }
+
+        Column {
+            anchors.fill: parent
+            anchors.margins: 10
+            spacing: 8
+
+            function styleButton(btn) {
+                btn.color = Qt.rgba(0.12, 0.12, 0.12, 0.95)
+                btn.border.width = 1
+                btn.border.color = Qt.rgba(1.0, 1.0, 1.0, 0.10)
+                btn.radius = 7
+            }
+
+            Rectangle {
+                id: btnSettings
+                width: menu.width - 20
+                height: 28
+                Component.onCompleted: menuCol.styleButton(btnSettings)
+                Text { anchors.centerIn: parent; text: "Settings"; color: "white"; font.pixelSize: 12 }
+                MouseArea {
+                    anchors.fill: parent
+                    hoverEnabled: true
+                    onEntered: btnSettings.color = Qt.rgba(0.20, 0.20, 0.20, 0.98)
+                    onExited: btnSettings.color = Qt.rgba(0.12, 0.12, 0.12, 0.95)
+                    onClicked: { menu.visible = false; if (typeof ctrl !== "undefined") ctrl.openSettings(); }
+                }
+            }
+
+            Rectangle {
+                id: btnLock
+                width: menu.width - 20
+                height: 28
+                Component.onCompleted: menuCol.styleButton(btnLock)
+                Text { anchors.centerIn: parent; text: root.locked ? "Unlock Position" : "Lock Position"; color: "white"; font.pixelSize: 12 }
+                MouseArea {
+                    anchors.fill: parent
+                    hoverEnabled: true
+                    onEntered: btnLock.color = Qt.rgba(0.20, 0.20, 0.20, 0.98)
+                    onExited: btnLock.color = Qt.rgba(0.12, 0.12, 0.12, 0.95)
+                    onClicked: { menu.visible = false; if (typeof ctrl !== "undefined") ctrl.toggleLock(); }
+                }
+            }
+
+            Rectangle {
+                id: btnQuit
+                width: menu.width - 20
+                height: 28
+                Component.onCompleted: menuCol.styleButton(btnQuit)
+                Text { anchors.centerIn: parent; text: "Quit"; color: "white"; font.pixelSize: 12 }
+                MouseArea {
+                    anchors.fill: parent
+                    hoverEnabled: true
+                    onEntered: btnQuit.color = Qt.rgba(0.20, 0.20, 0.20, 0.98)
+                    onExited: btnQuit.color = Qt.rgba(0.12, 0.12, 0.12, 0.95)
+                    onClicked: { menu.visible = false; if (typeof ctrl !== "undefined") ctrl.quit(); }
+                }
+            }
+        }
+    }
+
+    MouseArea {
+        anchors.fill: parent
+        acceptedButtons: Qt.LeftButton | Qt.RightButton
+        property real lastX: 0
+        property real lastY: 0
+        property bool dragging: false
+
+        onPressed: (mouse) => {
+            if (mouse.button === Qt.RightButton) {
+                menu.visible = !menu.visible
+                mouse.accepted = true
+                return
+            }
+
+            if (!root.locked && mouse.button === Qt.LeftButton) {
+                dragging = true
+                lastX = mouse.x
+                lastY = mouse.y
+                mouse.accepted = true
+            }
+        }
+
+        onReleased: (mouse) => {
+            dragging = false
+        }
+
+        onPositionChanged: (mouse) => {
+            if (!dragging) return
+            const dx = mouse.x - lastX
+            const dy = mouse.y - lastY
+            if (typeof ctrl !== "undefined") ctrl.moveBy(dx, dy)
+        }
+    }
+}
